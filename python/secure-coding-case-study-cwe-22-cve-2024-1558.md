# PATH TRAVERSAL IN MLFLOW

### Introduction:

Many software systems read and write files based on user input. If the software does not safely check or clean these file paths, an attacker can trick it into reading files that should never be exposed. This type of mistake is known as a path traversal and is one of the most common and dangerous issues in real software. In 2024, a path traversal vulnerability (CVE-2024-1558) was found in the MLflow Model Registry. MLflow is a popular machine learning lifecycle tool used by many companies. The issue came from the way MLflow validated the `source` field when creating a model version. The code only checked part of the path and later used the full value. This may cause an attacker to read sensitive files from the MLflow server. This case study explains the weakness, walks through the vulnerable code, shows how an attacker could abuse it, and describes how the MLflow team fixed it.

### Software:

**Name:** MLflow  
**Language:** Python  
**URL:** https://github.com/mlflow/mlflow

### Weakness:

<a href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory</a>

This weakness occurs when software uses a file path that comes from outside input but does not check it properly. Attackers can include special values like `..`, `/`, or encoded versions (`%2e%2e%2f`) to escape from a safe directory and reach files elsewhere on the system.

A simple example in Python:

```
def read_file(name):
    base = "/var/app/files"
    full_path = base + "/" + name   # BAD: no validation
    return open(full_path).read()
```

If a user sends:

```
../../etc/passwd
```

the OS may turn this into:

```
/etc/passwd
```

giving access to sensitive data.

Common causes include:

- Checking only part of a URI
- Failing to normalize or clean the path
- Treating paths as strings instead of using structured tools (`pathlib`, `urlparse`)
- Using the unvalidated value later in the code

The MLflow issue is a direct example of these mistakes.

### Vulnerability:

<a href="https://www.cve.org/CVERecord?id=CVE-2024-1558">CVE-2024-1558</a> – Published 16 April 2024

MLflow lets users create a model version by providing a `source` field on line 1752 that points to the model's artifact location. This user-provided source location is passed to the _validate_source() function on line 1760.

```
vulnerable file: mlflow/server/handlers.py

 1747  def _create_model_version():
 1748     request_message = _get_request_message(
 1749        CreateModelVersion(),
 1750        schema={
 1751           "name": [_assert_string, _assert_required],
 1752           "source": [_assert_string, _assert_required],
 1753           "run_id": [_assert_string],
 1754           "tags": [_assert_array],
 1755           "run_link": [_assert_string],
 1756           "description": [_assert_string],
 1757        },
 1758     )
 1759
 1760     _validate_source(request_message.source, request_message.run_id)
```

The _validate_source() function is defined earlier in the same vulnerable file on line 1723. This function attempts to check that the provided source location is local to the server, and if so will return on line 1731 with the implication that the source is valid and the model creation can continue. If it is not local, then additional validation to help prevent path traversal is performed via the call to _validate_non_local_source_contains_relative_paths() on line 1742.

```diff
vulnerable file: mlflow/server/handlers.py

 1723  def _validate_source(source: str, run_id: str) -> None:
 1724     if is_local_uri(source):
 1725        if run_id:
 ...
 1728           source = pathlib.Path(local_file_uri_to_path(source)).resolve()
-1729           run_artifact_dir = pathlib.Path(local_file_uri_to_path(run.info.artifact_uri)).resolve()
-1730           if run_artifact_dir in [source, *source.parents]:
-1731              return
 ...
 1740     # Checks if relative paths are present in the source (a security threat). If any are present,
 1741     # raises an Exception.
 1742     _validate_non_local_source_contains_relative_paths(source)
```

However, specially crafted source locations can pass this first validation and skip the path traversal related validation. Line 1728  of the vulnerable file calls the MLflow function local_file_uri_to_path() which converts a URI to local filesystem path. This function parses the provided source URI (line 504) and then focuses on the path component (line 505). This ignores parts like:

```
file:///safe/path?x=../../../../etc/passwd
```

Since the `path` (`/safe/path`) looks harmless, validation passes. Later code still uses the full original value, including the dangerous query string. When MLflow later joins this `source` with a user-supplied artifact path, the filesystem operations may escape into arbitrary locations.

```
supporting file: mlflow/utils/file_utils.py

 497  def local_file_uri_to_path(uri):
 ...
 502     path = uri
 503     if uri.startswith("file:"):
 504        parsed_path = urllib.parse.urlparse(uri)
 505        path = parsed_path.path
 ...
 509      return urllib.request.url2pathname(path)
```

Later, MLflow uses this `source` value to locate files on disk when a client asks for artifacts.

### Exploit:

<a href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a>

An attacker can exploit this by storing a model with a crafted `source` value, then requesting an artifact based on that stored value.

Step 1 — Create a Fake Model Version

The attacker sends:

```
POST /api/2.0/mlflow/model-versions/create
{
  "name": "badmodel",
  "source": "file:///mlruns/0/abc/artifacts/model?x=../../../../etc/passwd",
  "run_id": "abc"
}
```

The validator looks only at:

```
/mlruns/0/abc/artifacts/model
```

and accepts it.

Step 2 — Request an Artifact

```
GET /api/2.0/mlflow/model-versions/get-artifact?name=badmodel&version=1&path=whatever
```

Internally, MLflow joins the unsafe stored source with the provided artifact path. Because the original unsafe URI remains unchanged, MLflow may open `/etc/passwd` or any file readable by the server.

### Fix:

MLflow fixed the issue in **version 2.12.1**.

The fix includes two important parts:

1. Stronger validation and normalization  
2. Using only the validated value everywhere

### Fixed Code 

```
fixed file: mlflow/server/handlers.py

def _validate_and_normalize_source(source):
    parsed = urllib.parse.urlparse(source)

    if parsed.scheme not in ["file", "s3", "gs"]:
        raise MlflowException("Unsupported scheme")

    normalized = pathlib.PurePosixPath(urllib.parse.unquote(parsed.path))
    if ".." in normalized.parts:
        raise MlflowException("Relative paths not allowed")

    safe_parsed = parsed._replace(path=str(normalized))
    return safe_parsed.geturl()

def _create_model_version():
    req = _get_request_message(CreateModelVersion())
    safe_source = _validate_and_normalize_source(req.source)

    model_version = registry.create_model_version(
        name=req.name,
        source=safe_source,
        run_id=req.run_id,
    )
```


### Prevention:

1. Treat Paths and URIs as Structured Data. Use `urlparse`, `pathlib`, and normalized paths instead of raw strings.

2. Enforce a Base Directory. Always ensure that resolved paths remain inside an allowed root.

3. Validate Once, Use the Validated Value. Never validate a value then use the unvalidated version later.

4. Allowlist Allowed Schemes. Block unexpected schemes entirely.

5. Normalize and Decode Paths. Prevent traversal attempts before doing any file access.

6. Add Tests for Path Traversal. Test encoded and unencoded traversal cases.

7. Use Code Review and Static Analysis. Check for unsafe path handling during reviews.

### Conclusion:

CVE-2024-1558 shows how partial validation of a file path can lead to serious security issues. MLflow validated only part of the URI and then used the original value to read files. An attacker could use this to read sensitive files from the server. MLflow fixed the issue by normalizing paths, checking schemes, and using only the validated value. These practices help reduce the chance of similar bugs in other systems.

### References:

MLflow Project Page: https://github.com/mlflow/mlflow

CVE-2024-1558 Entry: https://www.cve.org/CVERecord?id=CVE-2024-1558

CWE-22 Entry: https://cwe.mitre.org/data/definitions/22.html

CAPEC-126 Entry: https://capec.mitre.org/data/definitions/126.html

GitHub Advisory (GHSA-j62r-wxqq-f3gf): https://github.com/advisories/GHSA-j62r-wxqq-f3gf

OSV Report: https://osv.dev/vulnerability/GHSA-j62r-wxqq-f3gf

NVD Vulnerability Report: https://nvd.nist.gov/vuln/detail/CVE-2024-1558

Huntr Report: https://huntr.com/bounties/7f4dbcc5-b6b3-43dd-b310-e2d0556a8081

MLflow 2.12.1 Release Announcement: https://groups.google.com/g/mlflow-users/c/-dCOO9wj2Tw

Related Pull Request: MLflow PR #11376  https://github.com/mlflow/mlflow/pull/11376

### Contributions:

Originally created by Kanishk Vardan Gokula Krishnan – George Mason University  
Reviewed by Steve Christey - The MITRE Corporation  
Reviewed by Drew Buttner - The MITRE Corporation  

(C) 2025 The MITRE Corporation. All rights reserved.  
This work is openly licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0</a>  
