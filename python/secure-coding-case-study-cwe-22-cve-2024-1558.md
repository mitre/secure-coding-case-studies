# PATH TRAVERSAL IN MLFLOW

### Introduction:

Many software systems read and write files based on user input. If the software does not safely check or clean these file paths, an attacker can trick it into reading files that should never be exposed. This type of mistake is known as a path traversal and is one of the most common and dangerous issues in real software. In 2024, a path traversal vulnerability (CVE-2024-1558) was found in the MLflow Model Registry. MLflow is a popular machine learning lifecycle tool used by many companies. The issue came from the way MLflow validated the `source` field when creating a model version. The code only checked part of the path and later used the full value. This may cause an attacker to read sensitive files from the MLflow server. This case study explains the weakness, walks through the vulnerable code, shows how an attacker could abuse it, and describes how the MLflow team fixed it.

### Software:

**Name:** MLflow  
**Language:** Python  
**URL:** https://github.com/mlflow/mlflow

### Weakness:

<a href="https://cwe.mitre.org/data/definitions/22.html">CWE-22: Improper Limitation of a Pathname to a Restricted Directory</a>

This weakness occurs when software uses a file path that comes from outside input but does not check it properly. Attackers can include special values like `..`, `/`, or encoded versions (`%2e%2e%2f`) to escape from a safe directory and reach files elsewhere on the system. A simple example in Python is as follows:

```
def read_file(name):
    base = "/var/app/files"
    full_path = base + "/" + name   # BAD: no validation of the name parameter
    return open(full_path).read()
```

If a user provides the follow for the name parameter:

```
../../etc/passwd
```

then the code would construct the following path:

```
/var/app/file/../../etc/passwd
```

which when resolved becomes:

```
/var/etc/passwd
```

This is obviously outside of the intended base directory and could result in the user accessing sensitive files on the system.

Common causes include:

- Checking only part of a URI
- Failing to normalize or clean the path
- Treating paths as strings instead of using structured tools (`pathlib`, `urlparse`)
- Using the unvalidated value later in the code

The MLflow issue is a direct example of these mistakes.

### Vulnerability:

<a href="https://www.cve.org/CVERecord?id=CVE-2024-1558">CVE-2024-1558</a> – Published 16 April 2024

MLflow lets users create a model version by providing a `source` field on line 1752 that points to the model's artifact location. This user-provided source location is passed to the _validate_source() function on line 1760.

```
vulnerable file: mlflow/server/handlers.py

 1747  def _create_model_version():
 1748     request_message = _get_request_message(
 1749        CreateModelVersion(),
 1750        schema={
 1751           "name": [_assert_string, _assert_required],
 1752           "source": [_assert_string, _assert_required],
 1753           "run_id": [_assert_string],
 1754           "tags": [_assert_array],
 1755           "run_link": [_assert_string],
 1756           "description": [_assert_string],
 1757        },
 1758     )
 1759
 1760     _validate_source(request_message.source, request_message.run_id)
```

The _validate_source() function is defined earlier in the same vulnerable file on line 1723. The first check performed on line 1724 is if the provided source is a local file path which in short is when the URI scheme is empty (i.e., the source starts with 'file:/' or just a '/'). Specific validation and checks are performed in this situation, but this case study is focused on the situation where the provided source is not local and instead has a scheme such as 'http://'. In these situations, the _validate_non_local_source_contains_relative_paths() function is called on line 1742.

```
vulnerable file: mlflow/server/handlers.py

 1723  def _validate_source(source: str, run_id: str) -> None:
 1724     if is_local_uri(source):
 ...
 1740     # Checks if relative paths are present in the source (a security threat). If any are present,
 1741     # raises an Exception.
 1742     _validate_non_local_source_contains_relative_paths(source)
```

The validate_non_local_source_contains_relative_paths() function checks to ensure that the source URI does not contain relative path designations such as `../` which are common in path traversal attacks. Instead, an absolute path must be provided. The first step in this is on line 1709 which uses the unquote_plus() call to replace escape codes (e.g., %20, %23, %2e, %2F) with their single-character equivalent. Then on line 1711 the URI is parsed and the path component is saved in the variable source_path with any trailing `/` characters removed along with any `+` characters. On line 1712 there is a check for null characters (represented as \x00) in the source_path and if any are found an exception is thrown. The last step is to use the resolve() function on line 1714 which resolves any symlinks and `..` structures. Finally, on line 1719 the resolved_path is compared to the saved source path and if there is a different an exception is thrown. This comparison of the resolved path to the original path is a well-practiced guard against path traversal attacks.

```
vulnerable file: mlflow/server/handlers.py

 1685  def _validate_non_local_source_contains_relative_paths(source: str):
 ...
 1709     while (unquoted := urllib.parse.unquote_plus(source)) != source:
 1710        source = unquoted
 1711     source_path = re.sub(r"/+", "/", urllib.parse.urlparse(source).path.rstrip("/"))
 1712     if "\x00" in source_path:
 1713        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
 1714     resolved_source = pathlib.Path(source_path).resolve().as_posix()
 ...
 1719     if resolved_path != source_path:
 1720        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
```

However, the validation code above only checks the path component of the URI. (see line 1711) By definition, URIs can have other components (e.g., general structure of a URI is scheme://netloc/path;parameters?query#fragment) which means `..` structures could still exist in those components. For example:

```
http://safe/dir#../../../../etc/passwd
```

The exploit section will show how MLflow uses this `source` value later in the code to locate files on disk when a client asks for artifacts.

### Exploit:

<a href="https://capec.mitre.org/data/definitions/126.html">CAPEC-126: Path Traversal</a>

An attacker can exploit this vulnerability by submitting a crafted `source` value with `..` structures in a fragment section. The example exploit value first presented by ozelis is:

```
source = "http:///xxx%23/api/2.0/mlflow-artifacts/artifacts/../../../../../../../../../../../"
```

Within the validation function, the `%23` escape code gets unquoted to the `#` character and everything after that is treated as a fragment. As mentioned in the vulnerability section above, only the path component is checked for `..` structures. The path in the provided source string is xxx and this passes the validation. The entire provided source string (including the fragment) is then passed to the CreateModelVersion operation.

The malicious source path (including the fragment) is used to build an artifact root that follows the `..` structures and enables access to files outside of the intended sphere. Additional vulnerabilities within MLflow (CVE-2024-1483, CVE-2024-1560, CVE-2024-3848, and CVE-2024-8859) contribute to the success of the exploit.

### Fix:

MLflow attempted to fix the issue in version 2.12.1 but made additional improvements in version 2.17.0 to complete the fix.

To fix the issue a change was made to the _validate_non_local_source_contains_relative_paths() function. Line 1838 was improved to not only look for null characters, but to also identify any `..` structures withing the entire source string including any fragments. If a sequence is found then an exception is thrown.

```diff
fixed file: mlflow/server/handlers.py

 1811  def _validate_non_local_source_contains_relative_paths(source: str):
 ...
 1835     while (unquoted := urllib.parse.unquote_plus(source)) != source:
 1836        source = unquoted
 1837     source_path = re.sub(r"/+", "/", urllib.parse.urlparse(source).path.rstrip("/"))
-1712     if "\x00" in source_path:
+1838     if "\x00" in source_path or any(p == ".." for p in source.split("/")):
 1839        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
 1840     resolved_source = pathlib.Path(source_path).resolve().as_posix()
 ...
 1845     if resolved_path != source_path:
 1846        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
```

An additional improvement was introduced in MLflow 3.0. A validation check was added directly to the _create_model_version() function to allow fine grained contol over the allowed format of the source parameter. An environment variable `MLFLOW_CREATE_MODEL_VERSION_SOURCE_VALIDATION_REGEX` can be set and is used on line 1983 as part of regular expression operations to validate the user provided source string.

```diff
fixed file: mlflow/server/handlers.py

 1966  def _create_model_version():
 1967     request_message = _get_request_message(
 1968        CreateModelVersion(),
 1969        schema={
 1970           "name": [_assert_string, _assert_required],
 1971           "source": [_assert_string, _assert_required],
 1972           "run_id": [_assert_string],
 1973           "tags": [_assert_array],
 1974           "run_link": [_assert_string],
 1975           "description": [_assert_string],
 1976           "model_id": [_assert_string],
 1977        },
 1978     )
 1979
+1980     if request_message.source and (
+1981        regex := MLFLOW_CREATE_MODEL_VERSION_SOURCE_VALIDATION_REGEX.get()
+1982     ):
+1983        if not re.search(regex, request_message.source):
+1984           raise MlflowException(
 ...
 1994           _validate_source_run(request_message.source, request_message.run_id)
```

### Prevention:

To prevent similar types of path traversal issues in future codebases developers should consider the following best practices:

1. Treat Paths and URIs as Structured Data: Use `urlparse`, `pathlib`, and normalized paths instead of raw strings.

2. Enforce a Base Directory: Always ensure that resolved paths remain inside an allowed root.

3. Validate Once, Use the Validated Value: Never validate a value then use the unvalidated version later.

4. Allowlist Allowed Schemes: Block unexpected schemes entirely.

5. Normalize and Decode Paths: Prevent traversal attempts before doing any file access.

6. Add Tests for Path Traversal: Test encoded and unencoded traversal cases.

7. Use Code Review and Static Analysis: Check for unsafe path handling during reviews.

### Conclusion:

CVE-2024-1558 shows how partial validation of a file path can lead to serious security issues. MLflow validated only part of the URI and then used the original value to create the model. An attacker could leverage this to eventually read sensitive files from the server. MLflow fixed the issue by normalizing paths, checking schemes, and validating the value. These practices help reduce the chance of similar bugs in other systems.

### References:

MLflow Project Page: https://github.com/mlflow/mlflow

CVE-2024-1558 Entry: https://www.cve.org/CVERecord?id=CVE-2024-1558

CWE-22 Entry: https://cwe.mitre.org/data/definitions/22.html

CAPEC-126 Entry: https://capec.mitre.org/data/definitions/126.html

GitHub Advisory (GHSA-j62r-wxqq-f3gf): https://github.com/advisories/GHSA-j62r-wxqq-f3gf

OSV Report: https://osv.dev/vulnerability/GHSA-j62r-wxqq-f3gf

NVD Vulnerability Report: https://nvd.nist.gov/vuln/detail/CVE-2024-1558

Huntr Report: https://huntr.com/bounties/7f4dbcc5-b6b3-43dd-b310-e2d0556a8081

MLflow 2.12.1 Release Announcement: https://groups.google.com/g/mlflow-users/c/-dCOO9wj2Tw

Related Pull Request: MLflow PR #11376  https://github.com/mlflow/mlflow/pull/11376

Related Pull Request: MLflow PR #13161  https://github.com/mlflow/mlflow/pull/13161

### Contributions:

Originally created by Kanishk Vardan Gokula Krishnan – George Mason University  
Reviewed by Steve Christey - The MITRE Corporation  
Reviewed by Drew Buttner - The MITRE Corporation  

(C) 2025 The MITRE Corporation. All rights reserved.  
This work is openly licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0</a>  
