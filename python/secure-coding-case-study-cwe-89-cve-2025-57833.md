# SQL INJECTION IN DJANGO

## Introduction

This case study is on CVE-2025-57833, a SQL injection vulnerability in Django’s FilteredRelation disclosed on September 3, 2025. It affects Django 4.2 (before 4.2.24), 5.1 (before 5.1.12), and 5.2 (before 5.2.6) and is rated High (CVSS 8.1) on NVD. The flaw occurs when FilteredRelation fails to validate column alias identifiers during dictionary expansion via user input passed to QuerySet.annotate(), allowing attacker-controlled keys to shape generated SQL. This matters because it shows SQL injection can surface in a mature, security-focused framework not through tainted values, but through dynamic identifiers at an API boundary where developers often assume the ORM is fully protective. This case study emphasizes practical prevention: validate anything that can influence identifiers, default APIs to safe/constant naming, add static checks that flag risky dynamic SQL, use fuzz/property tests around query builders, and make reviews trace untrusted input into SQL structure so issues like this are caught before production.

## Software

**Name:** Django (Django Software Foundation)  
**Language:** Python  
**URL:** https://github.com/django/django  

## Weakness

[CWE-89: Improper Neutralization of Special Elements Used in an SQL Command](https://cwe.mitre.org/data/definitions/89.html)

SQL injection exists when an attacker slips SQL commands into input that the app trusts, and that input gets treated as part of the query instead of data. When it works, the attacker can read sensitive rows, change or delete data, run admin actions on the database, and sometimes even reach the underlying OS. Similar to other types of injection attacks, untrusted input ends up controlling SQL structure, not just values, so the database executes something the developer never intended.

This weakness shows up when the app builds part of an SQL statement from outside input and does not neutralize characters that can change the statement’s structure. Only sanitizing inputs that are meant to be values within the SQL is not sufficient as if user input influences identifiers (like column names) then an attacker can slip in tokens (quotes, operators, keywords) that change how the query is parsed. In frameworks that support dynamic parameters, for example expanding a dictionary into a query, missing checks on those identifier-like inputs can bypass the safety of parameterized queries.

For example, a function may build a query like:

```
SELECT * FROM Users WHERE Username='$username';
```

The code would then check to see if any row in the database is returned. However, if an attacker provides the following value for $username `x'; DROP TABLE Users;--comment` then the final SQL becomes:

```
SELECT * FROM Users WHERE Username='x'; DROP TABLE Users;--comment'
```

In this example, the attacker has managed to insert a new SQL command that will be executed after the SELECT command.

## Vulnerability

[CVE-2025-57833](https://www.cve.org/CVERecord?id=CVE-2025-57833) – Published 3 September 2025

Looking at the vulnerable source code in Django, the issue is in add_filtered_relation() function defined on line 1722 that is part of the Query class which encapsulates all the SQL construction pertaining to a QuerySet as part of Django's Object-Relational Mapping (ORM). One of the features of the QuerySet is known as a FilteredRelation which is used to add annotations to the query. On line 1723 the alias name to such an annotation that is passed to the function is used to establish a new filtered_relation which is then added to the array filtered_relations\[\] on line 1756.

The issue is that the name of alias that is passed into this function on line 1722 comes from user-supplied inputs and is not neutralized leading to potential abuse of the SQL query that is generated.

```
vulnerable file: django/db/models/sql/query.py

  227 class Query(BaseExpression):
  ...
 1722    def add_filtered_relation(self, filtered_relation, alias):
 1723       filtered_relation.alias = alias
  ...
 1750       filtered_relation = filtered_relation.clone()
 1751       filtered_relation.condition = rename_prefix_from_q(
 1752           filtered_relation.relation_name,
 1753           alias,
 1754           filtered_relation.condition,
 1755       )
 1756       self._filtered_relations[filtered_relation.alias] = filtered_relation
```

The add_filtered_relation() function is called in on line 1739 of a parent query.py file. The alias that is used as a parameter is parsed from the annotations dictionary on line 1732 and was built on line 1715. Each arg that is added is of the form "alias_name = annotation" with the annotation to be of type FilteredRelation.

```
supporting file: django/db/models/query.py

 1698 def _annotate(self, args, kwargs, select=True):
  ...
 1702    annotations = {}
 1703    for arg in args:
  ...
 1715       annotations[arg.default_alias] = arg
  ...
 1718    clone = self._chain()
  ...
 1732    for alias, annotation in annotations.items():
  ...
 1738       if isinstance(annotation, FilteredRelation):
 1739          clone.query.add_filtered_relation(annotation, alias)
  ...
 1754    return clone
```

Unfortunately, the args parameter is derived from user input which enables the query to be maliciously altered. 

## Exploit

[CAPEC-66: SQL Injection](https://capec.mitre.org/data/definitions/66.html)

An attacker sends a crafted request so a user-controlled key ends up being used as an alias name in the annotate() call. When the app uses that dictionary to create the SQL query, the alias name is stitched into the SQL without validation. The injected characters change how the database parses the query.

```
{ x; DROP TABLE Users;--comment: Sum("price") }
```

Here, the provided name in the dict `x); DROP TABLE Users;--comment` becomes the alias identifier. Since that key is not validated against a safe pattern, special characters in it can leak into the generated SQL and change query structure.

## Fix

Django fixed this issue by validating the alias name before use. In django/db/models/sql/query.py, the add_filtered_relation() function was updated to first check that the alias name does not contain special characters. Only then is the alias used to build SQL. The line filtered_relation.alias = alias is the same assignment as before, but now it runs only after the alias passes validation, so later SQL construction cannot be bent by untrusted characters. Everything else in the function stays the same and is not part of the fix; by the time those execute, the alias is already safe.

```diff
fixed file: django/db/models/sql/query.py

  227 class Query(BaseExpression):
  ...
 1722    def add_filtered_relation(self, filtered_relation, alias):
+1723       self.check_alias(alias)
 1724       filtered_relation.alias = alias
  ...
 1751       filtered_relation = filtered_relation.clone()
 1752       filtered_relation.condition = rename_prefix_from_q(
 1753           filtered_relation.relation_name,
 1754           alias,
 1755           filtered_relation.condition,
 1756       )
 1757       self._filtered_relations[filtered_relation.alias] = filtered_relation
```

The check_alias() function enforces a safe identifier format and rejects anything that could tamper with SQL syntax. Putting it first blocks attacker-controlled keys from ever becoming raw SQL identifiers.

```
fixed file: django/db/models/sql/query.py

   54 Quotation marks ('"`[]), whitespace characters, control characters,
   55 semicolons, percent signs, hashes, or inline SQL comments are
   56 forbidden in column aliases.
   57 FORBIDDEN_ALIAS_PATTERN = _lazy_re_compile(
   58   r"['`\"\]\[;\s\x00-\x1F\x7F-\x9F]|%|#|--|/\*|\*/"
   59 )
  ...
 1216    def check_alias(self, alias):
  ...
 1229       if FORBIDDEN_ALIAS_PATTERN.search(alias):
 1230           raise ValueError(
 1231               "Column aliases cannot contain whitespace characters, quotation marks, "
  ...
 1235               "semicolons, or SQL comments."
 1236           )
```

## Prevention

***First***, treat identifiers (alias, column, table names) as untrusted, just like values. Put a strict rule in front of anything that could become an identifier (for example, only letters, digits, and underscores, and keep it length-limited) and reject or normalize everything else. The goal is to validate alias names before they ever reach the ORM so user input cannot shape SQL syntax.

***Second***, avoid dynamic aliasing by default. If you are using input to build queries, make alias names constants or pick them from a small, vetted map you control (for example: { "total": Sum("price"), "count": Count("id") }). If you truly need dynamic aliases, route them through the same validator as above, using one central helper so every call goes through the same gate.

***Third***, add automated checks that look specifically for this pattern. In CI, use a linter, CodeQL, or Semgrep rule to flag related calls in your code. A simple team rule also works: if user input feed query builders, there must be a nearby call to a validate_alias() helper (or use a documented constant map). Fail the build when the rule is violated.

***Fourth***, write a small property test or fuzzer for your query layer. Generate alias keys with punctuation, quotes, unicode, reserved words, and comment markers, and assert your code rejects or normalizes them before SQL is produced. Keep a few seeds (', ", --, /* */, ;, SELECT, FROM) so this becomes a regression test that proves the fix and stays green.

Most parameterized-statement systems can bind values but cannot bind identifiers (column/alias/table names). If your API accepts arbitrary identifiers, you cannot rely on parameterization to keep you safe—you must validate or map those identifiers before constructing SQL. Prefer mapping user choices to a small allowlist of constant identifiers; if you must accept free-form names, enforce a strict identifier regex (e.g., ^\[A-Za-z_\]\[A-Za-z0-9_\]{0,63}$) and reject anything that does not match before concatenation.

## Conclusion

This case study walked through a SQL injection in Django’s ORM where alias names from user input could flow into FilteredRelation and end up as SQL identifiers without any validation. It affected the supported 4.2, 5.1, and 5.2 branches before the September 2025 security releases. The core issue was untrusted input shaping SQL structure through identifiers, which normal parameter binding does not protect.

The fix was simple and effective: validate the alias first, then use it. The takeaways are just as direct: treat identifiers as untrusted, avoid dynamic aliasing unless it is validated, add automated checks, keep a small property test or fuzzer around query builders, use review checklists, and stay current with security releases. Do those consistently, and this class of bug becomes much easier to catch and much harder to ship.

## References

Django Security Release <https://www.djangoproject.com/weblog/2025/sep/03/security-releases/>

CVE-2025-57833 Entry: <https://www.cve.org/CVERecord?id=CVE-2025-57833>

CWE-89 Entry: <https://cwe.mitre.org/data/definitions/89.html>

NVD Vulnerability Report: <https://nvd.nist.gov/vuln/detail/CVE-2025-57833>

Django Code Commit to Fix Issue:: <https://github.com/django/django/commit/51711717098d3f469f795dfa6bc3758b24f69ef7>

Yunus Olcar Blog Post: <https://medium.com/@yunusolcardev/cve-2025-57833-potential-sql-injection-via-filteredrelation-aliases-in-django-1470fccab153>


## Contributions

Originally created by Siva Sai Mourya Pasupuleti - George Mason University  
Reviewed by Drew Buttner - The MITRE Corporation  

(C) 2026 The MITRE Corporation. All rights reserved.  
This work is openly licensed under [CC-BY-4.0](https://creativecommons.org/licenses/by/4.0/)

